#### 普通索引和唯一索引的选择

- 前提业务能够保证字段是唯一的地方能够保证唯一

**查询过程**

假如执行

```sql
select id form TR where k=5
```

这个查询在索引树上去寻找，从b+树的树根开始，然后到叶子节点：

> ​		如果是普通索引，找到  k=5 这个位置，然后还会向下判断一个位置，遇到第一个不满足  k =5 的条件再结束。
>
> ​		如果是唯一索引，因为索引定义了唯一性，查找到第一个满足条件后，就会停止继续检索

<font color="blue">其实这两者的性能差别并不是太大，相当来说是微乎其微。因为普通索引来说，也就是需要多做一次查找和判断下一条记录的操作，只需要一次指针寻找和一次计算 </font>  (<font color="red"> 尽管有可能  k = 5 这一条数据恰好在数据页最后一个，判断下一个需要将数据页从磁盘中重新加载到内存 这一点的消耗也是非常少的，并且一个数据页大小默认16k，对于整形字段，一个数据页可以放近千个key，所以总体上说性能影响不大</font>) 。



**更新过程**

> <font color="orange">change buffer:    </font>                                                                                
>
>          <font color="orange"> 当需要更新一个数据页的时候，这个数据页在内存中就直接更新，如果数据页没有在内存中的话，在不影响数据一致性的前提下，InooB将这些操作缓存在 change buffer 中，这样就不需要从磁盘中读入内存，将下一次要查询的时候或者change buffer 的定时器，会将change buffer数据merge到内存，然后执行change buffer中与这个页有关的操作。</font>
>
> ​		change buffer 实际上是持久化数据，在内存中有拷贝，也会被写入磁盘上。

如果更新记录在 change buffer 中，减少读磁盘，语句的执行速度得到明显的提升，而且，数据读入内存占用buffer pool ，这种方式还能避免占用内存，提高内存效率。

​		在唯一索引下，更新操作，首先判断这个操作是否违反唯一性约束。比如插入一个数值，需要判断整个表中是否已经存在，如果不存在就插入，反之。整个表的数据不一定都在内存中，这里的判断唯一性就涉及到从磁盘读入内存的开销。

​		在普通索引下，更新操作，不需要考虑太多东西，所以可以直接使用 change buffer，提升效率。



**关于索引的选择 **

​	所有的更新后面都马上伴随着对这个记录的查询，那么你应该关闭 change buffer, 其他情况下 change buffer 都能提升更新性能。

​	如果是在归档数据库中，建议将唯一索引改成普通索引。比如 order_travel_info 的数据移动到 order_history_info 中，写到history中肯定是没有唯一键冲突，提高效率的话，可以将表中的唯一索引改成普通索引。

> 如果需要使用唯一索引的地方，不使用。 墨菲定律回来搞你的



#### Mysql选错索引

- 如果由于索引统计信息不准确导致的问题，可以使用analyze table来解决。(我怎么知道是因为这个原因导致查询效率低下，要不写一个脚本每天定时执行一下？)
-  其他优化器误判的情况，你可以在应用端用 force index 来强行指定索引，也可以通过修改语句来引导优化器，还可以通过增加或者删除索引来绕过这个问题 

#### 给字符串加索引

